#' Estimate Standardized Regression Coefficients
#' and Generate the Corresponding Sampling Distribution
#' Using the Monte Carlo Method
#'
#' @details The empirical sampling distribution
#' of parameter estimates for the unstandardized regression model
#' is generated using the Monte Carlo method,
#' that is, random values of parameter estimates
#' are sampled from the multivariate normal distribution
#' using the estimated parameter vector as the mean vector
#' and the specified sampling covariance matrix using the `type` argument
#' as the covariance matrix.
#' The standardized regression coefficients are derived
#' from each randomly generated vector of parameters
#' to generate the empirical sampling distribution
#' of estimates of standardized slopes.
#' Confidence intervals are generated by obtaining
#' percentiles corresponding to \eqn{100(1 - \alpha)\%}
#' from the generated sampling
#' distribution of standardized slopes,
#' where \eqn{\alpha} is the significance level.
#'
#' @author Ivan Jacob Agaloos Pesigan
#'
#' @return Returns an object of class `betamc`
#'   which is a list with the following elements:
#'   \describe{
#'     \item{call}{Function call.}
#'     \item{lm}{Object of class `lm`.}
#'     \item{lm_process}{Pre-processed object of class `lm`.}
#'     \item{type}{Standard error type.}
#'     \item{thetahatstar}{List of parameters.}
#'     \item{thetahatstar_std}{Sampling distribution
#'                         of standardized slopes.}
#'     \item{vcov}{Sampling distribution
#'                 of standardized slopes.}
#'     \item{est}{Vector of standardized slopes.}
#' }
#'
#' @param object Object of class `lm`.
#' @param R Positive integer.
#'   Number of Monte Carlo replications.
#' @param type Character string.
#'   Sampling covariance matrix type.
#'   Possible values are
#'   `"mvn"`,
#'   `"adf"`,
#'   `"hc0"`,
#'   `"hc1"`,
#'   `"hc2"`,
#'   `"hc3"`,
#'   `"hc4"`,
#'   `"hc4m"`, and
#'   `"hc5"`.
#'   `type = "mvn"` uses the normal-theory sampling covariance matrix.
#'   `type = "adf"` uses the asymptotic distribution-free
#'   sampling covariance matrix.
#'   `type = "hc0"` through `"hc5"` uses different versions of
#'   heteroskedasticity-consistent sampling covariance matrix.
#' @param g1 Numeric.
#'   `g1` value for `type = "hc4m"` or `type = "hc5"`.
#' @param g2 Numeric.
#'   `g2` value for `type = "hc4m"`.
#' @param k Numeric.
#'   Constant for `type = "hc5"`
#' @param decomposition Character string.
#'   Matrix decomposition of the sampling variance-covariance matrix
#'   for the data generation.
#'   If `decomposition = "chol"`, use Cholesky decomposition.
#'   If `decomposition = "eigen"`, use eigenvalue decomposition.
#'   If `decomposition = "svd"`, use singular value decomposition.
#' @param pd Logical.
#'   If `pd = TRUE`,
#'   check if the sampling variance-covariance matrix
#'   is positive definite using `tol`.
#' @param tol Numeric.
#'   Tolerance used for `pd`.
#'
#' @references
#' Dudgeon, P. (2017).
#' Some improvements in confidence intervals
#' for standardized regression coefficients.
#' *Psychometrika*, *82*(4), 928â€“951.
#' \doi{10.1007/s11336-017-9563-z}
#'
#' Preacher, K. J., & Selig, J. P. (2012).
#' Advantages of Monte Carlo confidence intervals for indirect effects.
#' *Communication Methods and Measures*, *6*(2), 77-98.
#' \doi{10.1080/19312458.2012.679848}
#'
#' @examples
#' object <- lm(QUALITY ~ NARTIC + PCTGRT + PCTSUPP, data = nas1982)
#' std <- BetaMC(object, R = 100)
#' # use a large R, for example, R = 20000 for actual research
#' # Methods -------------------------------------------------------
#' print(std)
#' summary(std)
#' coef(std)
#' vcov(std)
#' confint(std, level = 0.95)
#' @export
#' @family Beta Monte Carlo Functions
#' @keywords betaMC std
BetaMC <- function(object,
                   R = 20000L,
                   type = "hc3",
                   g1 = 1,
                   g2 = 1.5,
                   k = 0.7,
                   decomposition = "eigen",
                   pd = TRUE,
                   tol = 1e-06) {
  lm_process <- .ProcessLM(object)
  stopifnot(
    type %in% c(
      "adf",
      "hc0",
      "hc1",
      "hc2",
      "hc3",
      "hc4",
      "hc4m",
      "hc5",
      "mvn"
    )
  )
  stopifnot(0 < k & k < 1)
  constant <- k
  jcap <- .JacobianVechSigmaWRTTheta(
    beta = lm_process$beta,
    sigmacapx = lm_process$sigmacap[
      2:lm_process$k,
      2:lm_process$k,
      drop = FALSE
    ],
    q = lm_process$q,
    p = lm_process$p,
    rsq = NULL
  )
  if (type == "adf") {
    gammacapmvn_consistent <- .GammaN(
      sigmacap = lm_process$sigmacap_consistent,
      pinv_of_dcap = lm_process$pinv_of_dcap
    )
    gammacap <- .GammaADFUnbiased(
      gammacapadf_consistent = .GammaADFConsistent(
        d = .DofMat(
          lm_process$x,
          center = colMeans(lm_process$x),
          n = lm_process$n,
          k = lm_process$k
        ),
        vechsigmacap_consistent = lm_process$vechsigmacap_consistent,
        n = lm_process$n
      ),
      gammacapmvn_consistent = gammacapmvn_consistent,
      vechsigmacap_consistent = lm_process$vechsigmacap_consistent,
      n = lm_process$n
    )
  }
  if (type == "mvn") {
    gammacap <- .GammaN(
      sigmacap = lm_process$sigmacap,
      pinv_of_dcap = lm_process$pinv_of_dcap
    )
  }
  if (type %in% c("adf", "mvn")) {
    # the procedure from here is the same for adf and mvn
    acov <- chol2inv(
      chol(
        .ACovSEMInverse(
          jcap = jcap,
          acov = gammacap
        )
      )
    )
    vcov <- (1 / lm_process$n) * acov
  }
  if (
    type %in% c(
      "hc0",
      "hc1",
      "hc2",
      "hc3",
      "hc4",
      "hc4m",
      "hc5"
    )
  ) {
    gammacap_mvn <- .GammaN(
      sigmacap = lm_process$sigmacap,
      pinv_of_dcap = lm_process$pinv_of_dcap
    )
    gammacap_hc <- .GammaHC(
      d = .DofMat(
        lm_process$x,
        center = colMeans(lm_process$x),
        n = lm_process$n,
        k = lm_process$k
      ),
      sigmacap = lm_process$sigmacap,
      qcap = .QMat(
        h = stats::hatvalues(object),
        k = lm_process$k,
        type = type,
        g1 = g1,
        g2 = g2,
        constant = constant
      ),
      n = lm_process$n
    )
    avcov <- .ACovHC(
      jcap = jcap,
      gammacap = gammacap_hc,
      gammacap_mvn = gammacap_mvn
    )
    vcov <- .CovHC(
      acov = avcov,
      type = type,
      n = lm_process$n,
      df = lm_process$df
    )
  }
  thetahatstar <- .ThetaHatStar(
    R = R,
    scale = vcov,
    location = lm_process$theta,
    decomposition = decomposition,
    pd = pd,
    tol = tol
  )$thetahatstar
  # rerun cases with negative variances
  # max iterations = iter
  foo <- function(x,
                  iter = 1000L) {
    bar <- function(x) {
      beta <- x[1:lm_process$p]
      sigmasq <- x[lm_process$k]
      sigmacapx <- .SymofVech(
        x = x[
          (lm_process$k + 1):lm_process$q
        ],
        k = lm_process$p
      )
      sigmaysq <- .SigmaYSq(
        beta = beta,
        sigmasq = sigmasq,
        sigmacapx = sigmacapx
      )
      return(
        list(
          beta = beta,
          sigmasq = sigmasq,
          sigmacapx = sigmacapx,
          sigmasqx = diag(sigmacapx),
          sigmaysq = sigmaysq
        )
      )
    }
    count <- 0
    params <- bar(x)
    sigmasq <- params$sigmasq
    sigmaysq <- params$sigmaysq
    sigmasqx <- params$sigmasqx
    while (
      any(
        c(
          sigmasq,
          sigmaysq,
          sigmasqx
        ) <= 0
      )
    ) {
      x <- .Vec(
        .ThetaHatStar(
          R = 1,
          scale = vcov,
          location = lm_process$theta,
          decomposition = decomposition,
          pd = FALSE
        )$thetahatstar
      )
      params <- bar(x)
      sigmasq <- params$sigmasq
      sigmaysq <- params$sigmaysq
      sigmasqx <- params$sigmasqx
      count <- count + 1
      if (count >= iter) {
        return(NA)
      }
    }
    return(params)
  }
  thetahatstar <- lapply(
    X = as.data.frame(
      t(
        thetahatstar
      )
    ),
    FUN = foo
  )
  thetahatstar <- thetahatstar[!is.na(thetahatstar)]
  thetahatstar_std <- lapply(
    X = thetahatstar,
    FUN = function(x) {
      return(
        .Vec(
          (
            sqrt(
              x$sigmasqx
            ) / sqrt(
              x$sigmaysq
            )
          ) * x$beta
        )
      )
    }
  )
  thetahatstar_std <- do.call(
    what = "rbind",
    args = thetahatstar_std
  )
  rownames(thetahatstar_std) <- NULL
  colnames(thetahatstar_std) <- lm_process$xnames
  out <- list(
    call = match.call(),
    lm = object,
    lm_process = lm_process,
    type = type,
    thetahatstar = thetahatstar,
    thetahatstar_std = thetahatstar_std,
    vcov = stats::var(thetahatstar_std),
    est = lm_process$betastar
  )
  class(out) <- c(
    "betamc",
    class(out)
  )
  return(
    out
  )
}
